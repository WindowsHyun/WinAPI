539 022571 01 027




[연습문제 3-8]

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define BSIZE 20

double LengthPts( int x1, int y1, int x2, int y2 ) {
	return( sqrt( (float)( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) ) ) );
}

BOOL InCircle( int x, int y, int mx, int my ) {
	if( LengthPts( x, y, mx, my ) < BSIZE ) return TRUE;
	else return FALSE;
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

LPCTSTR lpszClass = "Window Class";
HINSTANCE g_hInst;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow )
{
	HWND  hwnd;
	MSG   msg;
	WNDCLASS WndClass;

	WndClass.style = CS_HREDRAW | CS_VREDRAW;
	WndClass.lpfnWndProc = WndProc;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hInstance = hInstance;
	WndClass.hIcon = LoadIcon( NULL, IDI_APPLICATION );
	WndClass.hCursor = LoadCursor( NULL, IDC_ARROW );
	WndClass.hbrBackground = ( HBRUSH )GetStockObject( WHITE_BRUSH );
	WndClass.lpszMenuName = NULL;
	WndClass.lpszClassName = "my first window program";
	RegisterClass(&WndClass);

	hwnd = CreateWindow( "my first window program",
		"Window Title Name",
		WS_OVERLAPPEDWINDOW,
		0,
		0,
		800,
		600,
		NULL,
		NULL,
		hInstance,
		NULL
		);
	ShowWindow( hwnd, nCmdShow );
	UpdateWindow( hwnd );

	while( GetMessage( &msg, NULL, 0, 0 ) ) {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	}

	return msg.wParam;
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg,
	WPARAM wParam, LPARAM lParam )
{
	HDC hdc;
	PAINTSTRUCT ps;
	static double oldX, oldY;
	static double ciX, ciY;
	static BOOL drag, selec;
	static double startX, startY, endX, endY;
	static int cnt;
	int mx, my;

	switch( iMsg )
	{
	case WM_CREATE :
		startX = startY = 20;
		endX = endY = oldX = oldX = 20;
		drag = selec = FALSE; ciX = 20, ciY = 20;
		cnt = 0;
		break;

	case WM_LBUTTONDOWN :
		startX = mx = LOWORD( lParam );
		startY = my = HIWORD( lParam );
		if( InCircle( startX, startY, mx, my ) ) selec = TRUE;
		drag = TRUE;
		break;

	case WM_LBUTTONUP :
		drag = FALSE;
		if( selec ) {
			endX = LOWORD( lParam );
			endY = HIWORD( lParam );
			SetTimer( hwnd, 1, 70, NULL );
		}
		break;

	case WM_TIMER :
		ciX += ( endX-startX )/10;
		ciY += ( endY-startY )/10;
		++cnt;

		if( ciX >= endX-BSIZE && ciY >= endY-BSIZE )
			KillTimer(hwnd, 1);

		if( cnt == 10 )
			cnt = 0;

		InvalidateRgn( hwnd, NULL, TRUE );
		break;

	case WM_MOUSEMOVE :
		hdc = GetDC( hwnd );
		if( drag && selec ) {
			SetROP2( hdc, R2_XORPEN ); // 현 배경과 두 번째 인자를 연사안
			SelectObject( hdc, (HPEN) GetStockObject( WHITE_PEN ) );
			endX = LOWORD( lParam );
			endY = HIWORD( lParam );
			MoveToEx( hdc, startX, startY, NULL );
			LineTo( hdc, oldX, oldY ); // 지우기
			MoveToEx( hdc, startX, startY, NULL );
			LineTo( hdc, endX, endY ); // 그리기
			oldX = endX;
			oldY = endY;
		}
		ReleaseDC( hwnd, hdc );
		break;

	case WM_PAINT :
		hdc = BeginPaint( hwnd, &ps );
		Ellipse( hdc, ciX-BSIZE, ciY-BSIZE, ciX+BSIZE, ciY+BSIZE );
		if( selec ) {
			MoveToEx( hdc, startX, startY, NULL );
			LineTo( hdc, oldX, oldY );
			EndPaint( hwnd, &ps );
		}
		break;

	case WM_DESTROY :
		PostQuitMessage( 0 );
		KillTimer(hwnd, 1);
		break;
	}
	
	return ( DefWindowProc(hwnd, iMsg, wParam, lParam) );
}



[연습문제 3-9]


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define BSIZE 50

double LengthPts( double x1, double y1, double x2, double y2 ) {
	return( sqrt( (float)( (x2-x1)*(x2-x1) + (y2-y1)*(y2-y1) ) ) );
}

BOOL InCircle(double x, double y, double mx, double my)
{
	if(LengthPts(x, y, mx, my) < BSIZE) return TRUE;
	else return FALSE;
}

bool CircleInCircle( double x1, double y1, double x2, double y2,double Radius1, double Radius2)
{
	double  CharX = x1 - x2; // 물체1과 물체2의 x값만큼의 차이
	double  CharY = y1 - y2 ; //  물체1과 물체2의 y값만큼의 차이

	double distance = sqrt(CharX*CharX + CharY * CharY);   
	// distance 피타고라스의 정리에 따라서 c² = a² + b²

	if(distance <= Radius1 + Radius2) // 이 사잇값이 두 원의 반지름의 합보다 크면(+) 비충돌, 같거다면 경계면에 충돌 작다면(-) 충돌
		return TRUE; // 충돌하면
	else 
		return FALSE; // 아니면
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

LPCTSTR lpszClass = "Window Class";
HINSTANCE g_hInst;

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow )
{
	HWND  hwnd;
	MSG   msg;
	WNDCLASS WndClass;

	WndClass.style = CS_HREDRAW | CS_VREDRAW;
	WndClass.lpfnWndProc = WndProc;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hInstance = hInstance;
	WndClass.hIcon = LoadIcon( NULL, IDI_APPLICATION );
	WndClass.hCursor = LoadCursor( NULL, IDC_ARROW );
	WndClass.hbrBackground = ( HBRUSH )GetStockObject( WHITE_BRUSH );
	WndClass.lpszMenuName = NULL;
	WndClass.lpszClassName = "my first window program";
	RegisterClass(&WndClass);

	hwnd = CreateWindow( "my first window program",
		"Window Title Name",
		WS_OVERLAPPEDWINDOW,
		0,
		0,
		800,
		600,
		NULL,
		NULL,
		hInstance,
		NULL
		);
	ShowWindow( hwnd, nCmdShow );
	UpdateWindow( hwnd );

	while( GetMessage( &msg, NULL, 0, 0 ) ) {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	}

	return msg.wParam;
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg,
	WPARAM wParam, LPARAM lParam )
{
	HDC hdc;
	PAINTSTRUCT ps;
	HBRUSH hBrush, oldBrush;
	static double rada[10];
	static double x[10], y[10]; // 원 열개
	static double cX, cY;
	static BOOL selec, temp[10], end;
	static int cnt;
	static RECT window;
	static char str[50];
	int mx, my;

	switch( iMsg )
	{

	case WM_CREATE :
		srand( (unsigned) time( 0 ) );
		GetClientRect( hwnd, &window );
		cnt = 0; // 카운트 0부터어
		cX = cY = 0;
		selec = end = FALSE;

		for( int i = 0; i<10; ++i ) {
			x[i] = rand()%800;
			y[i] = rand()%600;
			rada[i] = rand()%95+5;
			temp[i] = FALSE;
		}
		for( int j = 0; j<10; ++j ) {
			x[j] = rand()%800;
			y[j] = rand()%600;
			rada[j] = rand()%95+5;
		}
		break;

	case WM_TIMER:
		break;

	case WM_LBUTTONDOWN :
		mx = LOWORD( lParam );
		my = HIWORD( lParam );
		if( InCircle( cX, cY, mx, my ) ) selec = TRUE;
		//InvalidateRgn( hwnd, NULL, TRUE );
		break;

	case WM_LBUTTONUP :
		selec = FALSE;
		break;

	case WM_MOUSEMOVE :
		mx = LOWORD( lParam );
		my = HIWORD( lParam );
		if( selec ) {
			cX = mx;
			cY = my;
			InvalidateRgn( hwnd, NULL, TRUE );
			for( int i = 0; i<10; ++i )
				if( CircleInCircle( cX, cY, x[i], y[i], BSIZE, rada[i] ) )
					temp[i] = TRUE;
		}

		if( mx+BSIZE > window.right && my+BSIZE > window.bottom ) {
			end = TRUE;
			selec = FALSE;
			for( int i = 0; i<10; ++i )
				if( temp[i] ) ++cnt;
			break;
		}

		break;

	case WM_PAINT :
		hdc = BeginPaint( hwnd, &ps );
		for( int i = 0; i<10; ++i ) {
			if( temp[i] )  // 충돌 했을 때
				hBrush = CreateSolidBrush( RGB( 255, 0, 0 ) ); // 빨강색
			else
				hBrush = CreateSolidBrush( RGB( 0, 255, 0 ) ); // 안 충돌 초록색

			oldBrush = (HBRUSH) SelectObject( hdc, hBrush );
			Ellipse( hdc, x[i]-rada[i], y[i]-rada[i], x[i]+rada[i], y[i]+rada[i] );
			SelectObject( hdc, oldBrush );
		}

		Ellipse( hdc, cX-BSIZE, cY-BSIZE, cX+BSIZE, cY+BSIZE );


		if( end ) {
			sprintf( str, "충돌한 공의 갯수는 %d 개 입니다.", cnt );
			TextOut( hdc, 300, 200, str, strlen(str) );
		}
		
		DeleteObject( hBrush );
		EndPaint( hwnd, &ps );
		break;

	case WM_DESTROY :
		PostQuitMessage(0);
		break;
	}

	return ( DefWindowProc(hwnd, iMsg, wParam, lParam) );
}


[연습문제 3-10]


#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <math.h>
#define BSIZE 20

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);

LPCTSTR lpszClass = "Window Class";
HINSTANCE g_hInst;

BOOL Check( int cX, int cY, int rX, int rY )
{	// rX-300, rY+495, rX+150, rY+545
	if( cY+BSIZE >= rY+495 && cX-BSIZE <= rX-300 && cX+BSIZE >= rX+150 )
		return TRUE;
	else 
		return FALSE;
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow )
{
	HWND  hwnd;
	MSG   msg;
	WNDCLASS WndClass;

	WndClass.style = CS_HREDRAW | CS_VREDRAW;
	WndClass.lpfnWndProc = WndProc;
	WndClass.cbClsExtra = 0;
	WndClass.cbWndExtra = 0;
	WndClass.hInstance = hInstance;
	WndClass.hIcon = LoadIcon( NULL, IDI_APPLICATION );
	WndClass.hCursor = LoadCursor( NULL, IDC_ARROW );
	WndClass.hbrBackground = ( HBRUSH )GetStockObject( WHITE_BRUSH );
	WndClass.lpszMenuName = NULL;
	WndClass.lpszClassName = "my first window program";
	RegisterClass(&WndClass);

	hwnd = CreateWindow( "my first window program",
		"Window Title Name",
		WS_OVERLAPPEDWINDOW,
		0,
		0,
		800,
		600,
		NULL,
		NULL,
		hInstance,
		NULL
		);
	ShowWindow( hwnd, nCmdShow );
	UpdateWindow( hwnd );

	while( GetMessage( &msg, NULL, 0, 0 ) ) {
		TranslateMessage( &msg );
		DispatchMessage( &msg );
	}

	return msg.wParam;
}

LRESULT CALLBACK WndProc( HWND hwnd, UINT iMsg,
	WPARAM wParam, LPARAM lParam )
{
	HDC hdc;
	PAINTSTRUCT ps;
	static int rX, rY, cX, cY;
	static int mX, mY, speed;
	static int temp;
	static RECT window;
	static BOOL selec, save;

	switch( iMsg )
	{

	case WM_CREATE :
		GetClientRect( hwnd, &window );
		speed = 70;
		SetTimer( hwnd, 1, speed, NULL );
		rX = 450, rY = 25;
		cX = 380, cY = 500;
		selec = save = FALSE;
		break;

	case WM_TIMER:
		switch( wParam ) {
		case 1 :
			cX -= 10;
			cY -= 10;
			temp = 1;
			if( cX-BSIZE <= window.left ) {
				KillTimer( hwnd, 1 );
 				SetTimer( hwnd, 2, speed, NULL );
			}
			break;
		case 2:
			cX += 10;
			cY -= 10;
			temp = 2;
			if( cY-BSIZE <= window.top ) {
				KillTimer( hwnd, 2 );
				SetTimer( hwnd, 3, speed, NULL );
			}
			break;
		case 3 :
			cX += 10;
			cY += 10;
			temp = 3;
			if( cX+BSIZE >= window.right ) {
				KillTimer( hwnd, 3 );
				SetTimer( hwnd, 4, speed, NULL );
			}
			break;
		case 4:
			cX -= 10;
			cY += 10;
			temp = 4;
			if( Check( cX, cY, rX, rY ) ) {
				KillTimer( hwnd, 4 );
				SetTimer( hwnd, 1, speed, NULL );
			}
			break;
		}
		InvalidateRgn( hwnd, NULL, TRUE );
		break;

	case WM_CHAR :	
		if( wParam == '=' ) {
			KillTimer( hwnd, temp );
			speed -=20;
			SetTimer( hwnd, temp, speed, NULL );
		}
		else if( wParam == '-' ) {
			KillTimer( hwnd, temp );
			speed += 20;
			SetTimer( hwnd, temp, speed, NULL );
		}
		break;

	case WM_LBUTTONDOWN :
		mX = LOWORD( lParam );
		mY = HIWORD( lParam );

		if( mX >= rX-300 && mX <= rX+150 && mY >= rY+495 && mY <= rY+545 )
			selec = TRUE;
		InvalidateRect (hwnd, NULL, TRUE );
		break;

	case WM_LBUTTONUP :
		selec = FALSE;
		break;

	case WM_RBUTTONDOWN :
		mX = LOWORD( lParam );
		mY = HIWORD( lParam );

		if( mX >= rX-300 && mX <= rX+150 && mY >= rY+495 && mY <= rY+545 )
			selec = TRUE;
		InvalidateRect (hwnd, NULL, TRUE );
		break;

	case WM_RBUTTONUP :
		selec = FALSE;
		save = FALSE;
		rX = 450, rY = 25;
		break;

	case WM_MOUSEMOVE :
		mX = LOWORD( lParam );
		mY = HIWORD( lParam );

		if( selec )
			rX = mX;

		InvalidateRgn( hwnd, NULL, TRUE );
		break;

	case WM_PAINT :
		hdc = BeginPaint( hwnd, &ps );
		Rectangle( hdc, rX-300, rY+495, rX+150, rY+545 );
		Ellipse( hdc, cX-BSIZE, cY-BSIZE, cX+BSIZE, cY+BSIZE );
		EndPaint( hwnd, &ps );
		break;

	case WM_DESTROY :
		PostQuitMessage(0);
		KillTimer( hwnd, 1 );
		KillTimer( hwnd, 2 );
		KillTimer( hwnd, 3 );
		KillTimer( hwnd, 4 );
		break;
	}

	return ( DefWindowProc(hwnd, iMsg, wParam, lParam) );
}